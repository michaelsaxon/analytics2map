<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>analytics2map</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson-client@3"></script>
    <script src="tz.js"></script>
    <link rel="stylesheet" href="https://saxon.me/theme/css/fonts.css" />
    <style>
      :root {
        color-scheme: light;
        font-family: "Berkeley Mono", monospace;
        background: #d8d5c4;
        color: #111;
      }
      body {
        margin: 0;
        background: #d8d5c4;
        color: #111;
      }
      .container {
        max-width: 900px;
        margin: 0;
        padding: 0 24px;
        line-height: 1.6;
        float: left;
      }
      h1 {
        font-size: 32px;
        margin-bottom: 8px;
        border-bottom: 1px solid #111;
        padding-bottom: 8px;
      }
      h2 {
        font-size: 24px;
        margin-top: 48px;
        margin-bottom: 12px;
        border-bottom: 1px solid #111;
        padding-bottom: 6px;
      }
      .full-width {
        margin: 0 auto;
        padding: 0 24px;
        text-align: center;
        padding-bottom: 12px;
        margin: 0;
        max-width: 900px;
        width: 100%;
        @media (min-width: 1848px) {
          max-width: 1848px;
        }
       }
      .full-width h1.title {
        text-align: center;

        font-size: 48px;
        margin-bottom: 8px;
        border-bottom: 1px solid #111;
        padding-bottom: 8px;
      }
      hr {
        margin: 20px 0;
        border: 0;
        border-top: 1px solid #111;
      }
      p {
        margin: 12px 0;
      }
      figure {
        margin: 24px auto 48px;
        text-align: center;
        width: 100%;
      }
      figcaption {
        font-size: 14px;
        color: #555;
        margin-top: 8px;
      }
      .map {
        display: block;
        border: 1px solid #ddd;
        background: #fff;
      }
      /* Globe rules */
      .globe-container {
        max-width: 800px;
        margin: 0 auto;
        position: relative;
      }
      .globe-frame {
        position: relative;
        border-radius: 12px;
        max-width: 100%;
      }
      /* Map rules */
      .map-frame {
        position: relative;
        border-radius: 12px;
        max-width: 100%;
      }
      .legend {
        position: absolute;
        bottom: 10px;
        right: 14px;
        padding: 6px 8px;
        border-radius: 8px;
        background: rgba(15, 23, 42, 0.78);
        font-size: 11px;
        color: #e5e7eb;
        border: 1px solid rgba(148, 163, 184, 0.4);
        display: flex;
        gap: 6px;
        align-items: center;
        backdrop-filter: blur(8px);
      }
      .legend-dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #dcd7ba;
        box-shadow: 0 0 0 1px #efede3;
      }
      .zoom-controls {
        position: absolute;
        top: 10px;
        left: 10px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        z-index: 10;
      }
      .zoom-button {
        width: 28px;
        height: 28px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: rgba(15, 23, 42, 0.92);
        color: #e5e7eb;
        font-size: 16px;
        line-height: 1;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
      }
      .zoom-button:hover {
        background: rgba(30, 64, 175, 0.95);
        border-color: rgba(129, 140, 248, 0.9);
      }
      /* Shared globe and map rules */
      svg {
        display: block;
        width: 100%;
        height: auto;
      }
      .tooltip {
        position: absolute;
        pointer-events: none;
        background: rgba(15, 23, 42, 0.94);
        color: #dcd7ba;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        line-height: 1.4;
        border: 1px solid #dcd7ba;
        opacity: 0;
        transform: translate(-50%, -140%);
        white-space: nowrap;
        z-index: 5;
      }
      .tooltip strong {
        font-weight: 600;
      }
      .visitor-stats {
        position: absolute;
        top: 10px;
        right: 14px;
        padding: 8px 12px;
        border-radius: 8px;
        background: rgba(37, 43, 59, 0.92);
        font-size: 12px;
        color: #dcd7ba;
        border: 1px solid #aca684;
        backdrop-filter: blur(8px);
        line-height: 1.6;
      }
      .visitor-stats strong {
        font-weight: 600;
        color: #f65151;
      }
      .stat-row {
        display: flex;
        justify-content: space-between;
        gap: 12px;
      }
     </style>
  </head>
  <body>

<main class="full-width"><h1 class="title">saxon.me visitor map</h1></main>

<main class="full-width">


  <h1>Dynamic visitor map: interactive map view</h1>
  <p>
    The interactive map view allows you to zoom in for more detail.
    Use the + and − buttons to zoom, or drag to pan the map.
  </p>
  <div class="map-frame" id="map-frame">
    <div class="zoom-controls">
      <button class="zoom-button" id="zoom-in" type="button">+</button>
      <button class="zoom-button" id="zoom-out" type="button">−</button>
    </div>
    <div class="visitor-stats" id="visitor-stats">
            <div class="stat-row">
              <span>Total:</span>
              <strong id="total-visitors">0</strong>
            </div>
            <div class="stat-row">
              <span>Visible:</span>
              <strong id="visible-visitors">0</strong>
            </div>
          </div>
          <div class="tooltip" id="tooltip"></div>
        </div>

  <hr>


    </main>


      <main class="container">



      <h1>Dynamic visitor map: globe view</h1>
      <p>This globe representation of recent visitors is updated hourly along with the static svg maps. Mouseover to see location, total visitors, and the most recent visit time.</p>

      <div class="globe-container">
        <div class="globe-frame" id="globe-frame">
          <div class="visitor-stats">
            <div class="stat-row">
              <span>Total:</span>
              <strong id="total-visitors">0</strong>
            </div>
            <div class="stat-row">
              <span>Visible:</span>
              <strong id="visible-visitors">0</strong>
            </div>
          </div>
          <div class="tooltip" id="tooltip"></div>
        </div>
      </div>
      <p>
        Approximate locations of visitors are aggregated by city and country.
        All maps on this page are generated using my <a href="https://github.com/michaelsaxon/analytics2map">analytics2map</a> tool from live Google Analytics data.
      </p>

      <hr>


      </main>
      <main class="container">
      <h1>About the analytics2map package</h1>
      <p>
        analytics2map is a simple static site visitor map renderer by Michael Saxon. It turns Google Analytics visit telemetry and historical
        Clustrmaps exports into simple static visitor maps. The stack is pure Python (Typer, Cartopy, svgwrite) and runs in a simple CLI.
      </p>
      <p>
        The pipeline periodically pulls incremental GA4 data and puts it in a TSV store. Finally, a renderer module reads out the TSV and writes 
        the SVG map. Each render emits a json file for dynamic d3js maps, two SVG files, an 800x400 one intended for embedding in a footer, and a higher-resolution one
        to be displayed full-width.
      </p>
      <p>
        Every day at midnight, a Github action pulls the latest visit data from Google Analytics and updates the maps.
        Since the repo itself is hosted on Github pages, I simply point my website at the map output URLs (in this repo).
        With a simple combination of static calls here, I replicate the functionality of fancy JS-based spy maps like Clustrmaps.
      </p>
      <p>Source code is available in my <a href="https://github.com/michaelsaxon/analytics2map">[analytics2map]</a> repository on GitHub.</p>
        <p><a href="https://saxon.me">[Go home]</a></p>
        <hr>

        <h1>Static SVG maps</h1>
        <p>Two sizes of SVG map are rendered: one for display in the web page footer at 300px and the other for full-width display at 900px.</p>
        <!-- <figure>
        <img
          class="map"
          style="max-width: 300px; width: 100%; height: auto; margin-left: auto; margin-right: auto;"
          height="150"
          src="output/visitors-small.svg"
          alt="Small visitor map preview"
        />
        <figcaption>Scaled-down preview of the 800×400 SVG.</figcaption>
        </figure> -->

      <figure>
        <img
          class="map"
            style="width: 100%; height: auto; margin-left: auto; margin-right: auto;"
          height="450"
          src="output/visitors-large.svg"
          alt="Large visitor map preview"
        />
          <figcaption>900px full-width SVG map.</figcaption>
      </figure>

        <hr>

    </main>


    <script>
      // ============ GLOBE VARIABLES ============
      const globe_size = 800;
      const globe_minRadius = 3;
      const globe_maxRadius = 12;
      const globe_theme = {
        landFill: "#dcd7ba",
        landStroke: "#efede3",
        waterFill: "#1f1f28",
        bubbleFill: "#7aa89f",
        bubbleStroke: "#3d6b62",
        bubbleFillHover: "#b31d1d",
        bubbleStrokeHover: "#db5555",
        bubbleOpacity: 0.75,
      };

      const globe_container = d3.select("#globe-frame");
      const globe_tooltip = d3.select("#globe-frame .tooltip");
      
      let globe_svg, globe_projection, globe_path, globe_visitData, globe_worldData;
      let globe_rotation = 0;
      const globe_rotationSpeed = 0.3; // degrees per frame
      let globe_recentVisitors = new Set(); // Track recent visitor locations
      let globe_activeTooltip = null; // Currently displayed auto-tooltip
      let globe_activeRipples = []; // Track active ripple animations with their geo coordinates
      let globe_tooltipSchedule = []; // Pre-computed schedule of tooltip displays

      // Load data
      Promise.all([
        d3.json("https://unpkg.com/world-atlas@2/countries-50m.json"),
        d3.json("output/visitors-data.json")
      ]).then(([world, visitorData]) => {
        globe_worldData = topojson.feature(world, world.objects.countries);
        globe_visitData = visitorData;
        
        // Select 15 visitors balancing recency with spatial distribution
        const selectedVisitors = globe_selectBalancedRecentVisitors(visitorData, 15);
        
        selectedVisitors.forEach(d => {
          globe_recentVisitors.add(`${d.lat},${d.lon}`);
        });
        
        console.log(`Showing ${globe_recentVisitors.size} balanced recent visitors as red dots`);
        
        // Pre-compute tooltip display schedule
        globe_computeTooltipSchedule(selectedVisitors);
        
        // Calculate total visitors for globe
        const globeTotalVisitors = globe_visitData.reduce((sum, d) => sum + d.visitors, 0);
        d3.select("#globe-frame #total-visitors").text(globeTotalVisitors.toLocaleString());
        
        globe_initGlobe();
        globe_animate();
      }).catch(error => {
        console.error("Error loading globe data:", error);
        globe_container.append("div")
          .style("padding", "20px")
          .style("color", "#ff6b6b")
          .text("Error loading data. Please ensure visitors-data.json is available.");
      });

      /**
       * Calculate geographic distance between two points in degrees
       * Uses simple Euclidean distance approximation (works well for small distances)
       */
      function globe_pointDistance(lat1, lon1, lat2, lon2) {
        const dLat = lat1 - lat2;
        const dLon = globe_angularDistance(lon1, lon2);
        return Math.sqrt(dLat * dLat + dLon * dLon);
      }

      /**
       * Deconflict visitors within K degrees of each other, keeping the newest ones
       * Algorithm:
       * 1. Sort by recency (newest first)
       * 2. For each visitor, if no already-selected visitor is within K degrees, keep it
       * 3. This naturally keeps the newest visitor when there are conflicts
       */
      function globe_deconflictNearbyVisitors(visitorData, K) {
        // Filter and sort by recency (newest first)
        const sorted = [...visitorData]
          .filter(d => d.lastVisit)
          .sort((a, b) => new Date(b.lastVisit) - new Date(a.lastVisit));
        
        const selected = [];
        
        for (const visitor of sorted) {
          // Check if there's already a selected visitor within K degrees
          const hasNearby = selected.some(selectedVisitor => {
            const distance = globe_pointDistance(
              visitor.lat, visitor.lon,
              selectedVisitor.lat, selectedVisitor.lon
            );
            return distance <= K;
          });
          
          // If no nearby visitor, add this one (it's the newest in its area)
          if (!hasNearby) {
            selected.push(visitor);
          }
        }
        
        return selected;
      }

      /**
       * Determine which 120-degree segment a longitude belongs to
       * Segment 1: Central/East Asia and Pacific (60°E to 180°E)
       * Segment 2: Pacific, Americas, Atlantic (180°E to 300°E / -60°W)
       * Segment 3: Atlantic, Africa, Europe, Middle East (300°E to 60°E / -60°W to 60°E)
       */
      function globe_getSegment(lon) {
        // Normalize longitude to [0, 360)
        const normalizedLon = ((lon % 360) + 360) % 360;
        
        if (normalizedLon >= 60 && normalizedLon < 180) {
          return 1; // Central/East Asia and Pacific
        } else if (normalizedLon >= 180 && normalizedLon < 300) {
          return 2; // Pacific, Americas, Atlantic
        } else {
          return 3; // Atlantic, Africa, Europe, Middle East (wraps around: 300-360 and 0-60)
        }
      }

      /**
       * Select N visitors balancing recency with spatial distribution
       * Algorithm:
       * 0. First deconflict nearby visitors (within K degrees, keep newest)
       * 1. Start with the 2N most recent visitors from deconflicted set
       * 2. Partition globe into 3 segments of 120 degrees each
       * 3. Count visitors in each segment
       * 4. Remove the oldest visitor from the segment with the most visitors
       * 5. Repeat until N visitors remain
       */
      function globe_selectBalancedRecentVisitors(visitorData, N, deconflictRadius = 10) {
        // Step 0: Deconflict nearby visitors first (within K degrees, keep newest)
        const deconflicted = globe_deconflictNearbyVisitors(visitorData, deconflictRadius);
        
        // Get 2N most recent visitors from deconflicted set
        const candidates = deconflicted
          .sort((a, b) => new Date(b.lastVisit) - new Date(a.lastVisit))
          .slice(0, 2 * N);
        
        // If we have N or fewer, return them all
        if (candidates.length <= N) {
          return candidates;
        }
        
        // Track original recency index and assign to segments
        const normalized = candidates.map((d, originalIdx) => ({
          visitor: d,
          lon: d.lon,
          segment: globe_getSegment(d.lon),
          originalIdx // Track original position (higher = less recent)
        }));
        
        // Greedily remove oldest from segment with most visitors until we have N
        let remaining = [...normalized];
        
        while (remaining.length > N) {
          // Count visitors per segment
          const segmentCounts = { 1: 0, 2: 0, 3: 0 };
          remaining.forEach(v => {
            segmentCounts[v.segment]++;
          });
          
          // Find segment with most visitors
          let maxSegment = 1;
          let maxCount = segmentCounts[1];
          if (segmentCounts[2] > maxCount) {
            maxSegment = 2;
            maxCount = segmentCounts[2];
          }
          if (segmentCounts[3] > maxCount) {
            maxSegment = 3;
            maxCount = segmentCounts[3];
          }
          
          // Find oldest visitor in that segment (highest originalIdx = least recent)
          let oldestInSegment = null;
          let oldestIdx = -1;
          
          remaining.forEach((visitor, idx) => {
            if (visitor.segment === maxSegment) {
              if (oldestInSegment === null || visitor.originalIdx > oldestInSegment.originalIdx) {
                oldestInSegment = visitor;
                oldestIdx = idx;
              }
            }
          });
          
          // Remove the oldest visitor from the segment with most visitors
          if (oldestIdx !== -1) {
            remaining.splice(oldestIdx, 1);
          } else {
            // Fallback: shouldn't happen, but break to avoid infinite loop
            break;
          }
        }
        
        // Return the original visitor objects
        return remaining.map(n => n.visitor);
      }

      /**
       * Pre-compute tooltip display schedule with overlap-aware partitioning
       * Algorithm:
       * 1. Sort visitors by: right-to-left (lon desc), then top-to-bottom (lat desc)
       * 2. For each visitor's 90-degree optimal window, find all overlapping visitors
       * 3. Partition the window equally among overlapping visitors in sorted order
       */
      function globe_computeTooltipSchedule(recentVisitors) {
        const MAX_DISPLAY_DEGREES = 90; // Maximum degrees a tooltip can be shown
        
        // Step 1: Sort visitors lexicographically: right-to-left, then top-to-bottom
        const sortedVisitors = recentVisitors.map((visitor, index) => {
          const lon = visitor.lon;
          const lat = visitor.lat;
          
          // Normalize longitude to [-180, 180]
          const normLon = ((lon + 180) % 360) - 180;
          
          return {
            visitor,
            lon: normLon,
            lat,
            key: `${lat},${lon}`
          };
        }).sort((a, b) => {
          // Primary: right to left (higher lon first)
          if (Math.abs(a.lon - b.lon) > 0.001) return b.lon - a.lon;
          // Secondary: top to bottom (higher lat first)
          return b.lat - a.lat;
        });
        
        // Step 2: For each visitor, compute their display window
        const schedule = [];
        
        sortedVisitors.forEach((visitor, idx) => {
          // A point at longitude L is centered when globe_rotation = -L
          // Normalize -L to [0, 360) first
          const rotationWhenCentered = ((-visitor.lon % 360) + 360) % 360;
          
          // Window spans 45 degrees on each side of center
          let windowStart = rotationWhenCentered - (MAX_DISPLAY_DEGREES / 2);
          let windowEnd = rotationWhenCentered + (MAX_DISPLAY_DEGREES / 2);
          
          // Normalize to [0, 360)
          windowStart = ((windowStart % 360) + 360) % 360;
          windowEnd = ((windowEnd % 360) + 360) % 360;
          
          // Find all visitors (in sorted order) whose optimal windows overlap with this one
          const overlappingInOrder = [];
          sortedVisitors.forEach((other) => {
            const otherRotationCenter = ((-other.lon % 360) + 360) % 360;
            const otherStart = ((otherRotationCenter - MAX_DISPLAY_DEGREES / 2) % 360 + 360) % 360;
            const otherEnd = ((otherRotationCenter + MAX_DISPLAY_DEGREES / 2) % 360 + 360) % 360;
            
            const overlap = globe_computeOverlap(windowStart, windowEnd, otherStart, otherEnd);
            if (overlap > 0) {
              overlappingInOrder.push(other);
            }
          });
          
          // Partition the window equally among overlapping visitors
          const numOverlapping = overlappingInOrder.length;
          const sharePerVisitor = MAX_DISPLAY_DEGREES / numOverlapping;
          
          // Find this visitor's position in the overlapping list
          const positionInOverlap = overlappingInOrder.findIndex(v => v.key === visitor.key);
          
          // Calculate start and end for this visitor
          const startOffset = positionInOverlap * sharePerVisitor;
          let displayStart = (windowStart + startOffset) % 360;
          let displayEnd = (displayStart + sharePerVisitor) % 360;
          
          schedule.push({
            key: visitor.key,
            visitor: visitor.visitor,
            displayStart,
            displayEnd,
            duration: sharePerVisitor,
            overlaps: numOverlapping,
            position: positionInOverlap,
            sortOrder: idx,
            lon: visitor.lon,
            lat: visitor.lat
          });
        });
        
        globe_tooltipSchedule = schedule;
        console.log(`Computed tooltip schedule for ${schedule.length} visitors:`, schedule);
      }
      
      /**
       * Calculate overlap between two angular windows (handles wrap-around)
       */
      function globe_computeOverlap(start1, end1, start2, end2) {
        // Convert to ranges that might wrap around 360
        const range1 = end1 >= start1 ? 
          [[start1, end1]] : 
          [[start1, 360], [0, end1]];
        
        const range2 = end2 >= start2 ? 
          [[start2, end2]] : 
          [[start2, 360], [0, end2]];
        
        let totalOverlap = 0;
        
        for (const [s1, e1] of range1) {
          for (const [s2, e2] of range2) {
            const overlapStart = Math.max(s1, s2);
            const overlapEnd = Math.min(e1, e2);
            if (overlapEnd > overlapStart) {
              totalOverlap += overlapEnd - overlapStart;
            }
          }
        }
        
        return totalOverlap;
      }
      
      /**
       * Calculate angular distance between two longitudes (shortest path)
       */
      function globe_angularDistance(lon1, lon2) {
        let diff = Math.abs(lon1 - lon2);
        if (diff > 180) {
          diff = 360 - diff;
        }
        return diff;
      }

      function globe_initGlobe() {
        // Create SVG
        globe_svg = globe_container
          .append("svg")
          .attr("viewBox", `0 0 ${globe_size} ${globe_size}`);

        // Orthographic projection for globe
        globe_projection = d3.geoOrthographic()
          .scale(globe_size / 2.2)
          .translate([globe_size / 2, globe_size / 2])
          .clipAngle(90);

        globe_path = d3.geoPath(globe_projection);

        // Draw sphere (ocean)
        globe_svg.append("path")
          .datum({type: "Sphere"})
          .attr("class", "sphere")
          .attr("d", globe_path)
          .attr("fill", globe_theme.waterFill)
          .attr("stroke", "rgba(148, 163, 184, 0.3)")
          .attr("stroke-width", 1.5);

        // Land
        globe_svg.append("g")
          .attr("class", "land")
          .selectAll("path")
          .data(globe_worldData.features)
          .join("path")
          .attr("d", globe_path)
          .attr("fill", globe_theme.landFill)
          .attr("stroke", globe_theme.landStroke)
          .attr("stroke-width", 0.5)
          .attr("stroke-opacity", 0.6)
          .attr("fill-opacity", 0.9);

        // Points groups - regular points first, then recent on top
        globe_svg.append("g").attr("class", "points-regular");
        globe_svg.append("g").attr("class", "points-recent");
        globe_svg.append("g").attr("class", "ripples");
      }

      function globe_animate() {
        globe_rotation += globe_rotationSpeed;
        globe_projection.rotate([globe_rotation, -20, 0]);

        // Update land
        globe_svg.select(".land")
          .selectAll("path")
          .attr("d", globe_path);

        // Update ripple positions to follow globe rotation
        globe_updateRipplePositions();

        // Update points
        globe_drawPoints();
        globe_updateVisibleCount();

        requestAnimationFrame(globe_animate);
      }

      function globe_drawPoints() {
        if (!globe_visitData || globe_visitData.length === 0) return;

        const radii = globe_visitData.map(d => d.normalized || 0);
        const maxNormalized = d3.max(radii) || 1;

        const radiusScale = d3.scaleLinear()
          .domain([0, maxNormalized])
          .range([globe_minRadius, globe_maxRadius]);

        // Separate data into regular and recent visitors
        const regularData = [];
        const recentData = [];
        
        globe_visitData.forEach(d => {
          if (globe_recentVisitors.has(`${d.lat},${d.lon}`)) {
            recentData.push(d);
          } else {
            regularData.push(d);
          }
        });

        // Sort regular data by size (largest first) so smaller dots render on top
        regularData.sort((a, b) => (b.normalized || 0) - (a.normalized || 0));

        // Draw regular visitors
        globe_drawRegularPoints(regularData, radiusScale);
        
        // Draw recent visitors (on top)
        globe_drawRecentPoints(recentData);

        // Auto-display tooltips for recent visitors in the center zone (middle 90 degrees)
        globe_updateAutoTooltips();
      }

      function globe_drawRegularPoints(data, radiusScale) {
        const circles = globe_svg.select(".points-regular")
          .selectAll("circle")
          .data(data, d => `${d.lat},${d.lon}`);

        circles.exit().remove();

        const enter = circles.enter()
          .append("circle")
          .attr("fill", globe_theme.bubbleFill)
          .attr("fill-opacity", globe_theme.bubbleOpacity)
          .attr("stroke", globe_theme.bubbleStroke)
          .attr("stroke-width", 1)
          .style("cursor", "default");

        const allCircles = circles.merge(enter)
          .attr("cx", d => {
            const proj = globe_projection([d.lon, d.lat]);
            return proj ? proj[0] : -999;
          })
          .attr("cy", d => {
            const proj = globe_projection([d.lon, d.lat]);
            return proj ? proj[1] : -999;
          })
          .attr("r", d => radiusScale(d.normalized || 0))
          .style("display", d => {
            const proj = globe_projection([d.lon, d.lat]);
            if (!proj) return "none";
            const distance = d3.geoDistance([d.lon, d.lat], globe_projection.invert([globe_size / 2, globe_size / 2]));
            return distance > Math.PI / 2 ? "none" : null;
          });

        // Handle manual hover tooltips
        allCircles
          .on("mouseover", function(event, d) {
            d3.select(this).attr("stroke-width", 1.4);

            const city = d.city && d.city.trim();
            const country = d.country && d.country.trim();
            const title = city ? `${city}, ${country || "Unknown"}` : (country || "Unknown");
            const timeDisplay = globe_formatLastVisit(d.lastVisit);

            const containerRect = globe_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;

            globe_tooltip
              .style("left", x + "px")
              .style("top", y + "px")
              .style("opacity", 1)
              .html(`<strong>${title}</strong><br/>${timeDisplay}`);
          })
          .on("mousemove", function(event) {
            const containerRect = globe_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;
            globe_tooltip.style("left", x + "px").style("top", y + "px");
          })
          .on("mouseout", function() {
            d3.select(this).attr("stroke-width", 1.0);
            globe_tooltip.style("opacity", 0);
          });
      }

      function globe_drawRecentPoints(data) {
        const circles = globe_svg.select(".points-recent")
          .selectAll("circle")
          .data(data, d => `${d.lat},${d.lon}`);

        circles.exit().remove();

        const enter = circles.enter()
          .append("circle")
          .attr("fill", globe_theme.bubbleFillHover)
          .attr("fill-opacity", globe_theme.bubbleOpacity)
          .attr("stroke", globe_theme.bubbleStrokeHover)
          .attr("stroke-width", 1)
          .attr("r", globe_minRadius)
          .style("cursor", "default");

        const allCircles = circles.merge(enter)
          .attr("cx", d => {
            const proj = globe_projection([d.lon, d.lat]);
            return proj ? proj[0] : -999;
          })
          .attr("cy", d => {
            const proj = globe_projection([d.lon, d.lat]);
            return proj ? proj[1] : -999;
          });

        // Check visibility
        allCircles.each(function(d) {
          const proj = globe_projection([d.lon, d.lat]);
          
          if (!proj) {
            d3.select(this).style("display", "none");
            return;
          }

          const centerLon = globe_projection.invert([globe_size / 2, globe_size / 2]);
          const distance = d3.geoDistance([d.lon, d.lat], centerLon);
          const isVisible = distance <= Math.PI / 2;
          
          d3.select(this).style("display", isVisible ? null : "none");
        });

        // Handle manual hover tooltips
        allCircles
          .on("mouseover", function(event, d) {
            d3.select(this).attr("stroke-width", 1.4);

            const city = d.city && d.city.trim();
            const country = d.country && d.country.trim();
            const title = city ? `${city}, ${country || "Unknown"}` : (country || "Unknown");
            const timeDisplay = globe_formatFullDateTime(d.lastVisit, d.lat, d.lon);

            const containerRect = globe_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;

            globe_tooltip
              .style("left", x + "px")
              .style("top", y + "px")
              .style("opacity", 1)
              .html(`<strong>${title}</strong><br/>${timeDisplay}`);
          })
          .on("mousemove", function(event) {
            const containerRect = globe_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;
            globe_tooltip.style("left", x + "px").style("top", y + "px");
          })
          .on("mouseout", function() {
            d3.select(this).attr("stroke-width", 1.0);
            globe_tooltip.style("opacity", 0);
          });
      }

      function globe_createRipple(lat, lon) {
        const startTime = Date.now();
        const duration = 600; // ms
        const startRadius = globe_minRadius * 4;
        const endRadius = globe_minRadius;
        
        const rippleId = `ripple-${Date.now()}-${Math.random()}`;
        
        const ripple = globe_svg.select(".ripples")
          .append("circle")
          .attr("class", rippleId)
          .attr("fill", "none")
          .attr("stroke", globe_theme.bubbleStrokeHover)
          .attr("stroke-width", 2);

        // Store ripple data for position updates
        globe_activeRipples.push({
          id: rippleId,
          lat: lat,
          lon: lon,
          startTime: startTime,
          duration: duration,
          startRadius: startRadius,
          endRadius: endRadius,
          element: ripple
        });
      }

      function globe_updateRipplePositions() {
        const now = Date.now();
        
        // Update all active ripples
        globe_activeRipples = globe_activeRipples.filter(ripple => {
          const elapsed = now - ripple.startTime;
          const progress = Math.min(elapsed / ripple.duration, 1);
          
          // Remove completed ripples
          if (progress >= 1) {
            ripple.element.remove();
            return false;
          }
          
          // Update position based on current globe rotation
          const proj = globe_projection([ripple.lon, ripple.lat]);
          if (!proj) {
            ripple.element.style("display", "none");
            return true;
          }
          
          // Check if on visible hemisphere
          const centerLon = globe_projection.invert([globe_size / 2, globe_size / 2]);
          const distance = d3.geoDistance([ripple.lon, ripple.lat], centerLon);
          if (distance > Math.PI / 2) {
            ripple.element.style("display", "none");
            return true;
          }
          
          // Calculate current radius and opacity based on animation progress
          const currentRadius = ripple.startRadius - (ripple.startRadius - ripple.endRadius) * progress;
          const currentOpacity = 0.8 * (1 - progress);
          
          // Update ripple position and appearance
          ripple.element
            .attr("cx", proj[0])
            .attr("cy", proj[1])
            .attr("r", currentRadius)
            .attr("opacity", currentOpacity)
            .style("display", null);
          
          return true;
        });
      }

      function globe_updateAutoTooltips() {
        // Use pre-computed schedule to determine which tooltip to show
        // Only consider start times - show tooltip when its start time is reached,
        // and hide it when the next tooltip's start time is reached
        const currentRotation = ((globe_rotation % 360) + 360) % 360;
        
        // Sort schedule by displayStart to find the active tooltip
        const sortedSchedule = [...globe_tooltipSchedule].sort((a, b) => {
          return a.displayStart - b.displayStart;
        });
        
        // Find the tooltip whose start time we've most recently passed
        // Show it until the next tooltip's start time
        let activeScheduleItem = null;
        
        for (let i = 0; i < sortedSchedule.length; i++) {
          const item = sortedSchedule[i];
          const nextItem = sortedSchedule[(i + 1) % sortedSchedule.length];
          
          const start = item.displayStart;
          const nextStart = nextItem.displayStart;
          
          // Check if current rotation is >= this item's start and < next item's start
          let isActive = false;
          
          if (nextStart > start) {
            // Normal case: no wrap-around between consecutive items
            isActive = currentRotation >= start && currentRotation < nextStart;
          } else {
            // Wrap-around case: next start wraps around 360
            // Active if: (rotation >= start) OR (rotation < nextStart)
            isActive = currentRotation >= start || currentRotation < nextStart;
          }
          
          if (isActive) {
            activeScheduleItem = item;
            break;
          }
        }
        
        if (activeScheduleItem) {
          const d = activeScheduleItem.visitor;
          const key = activeScheduleItem.key;
          
          // Check if this point is visible on the front hemisphere
          const proj = globe_projection([d.lon, d.lat]);
          if (!proj) {
            globe_tooltip.style("opacity", 0);
            globe_activeTooltip = null;
            return;
          }
          
          const centerLon = globe_projection.invert([globe_size / 2, globe_size / 2]);
          if (!centerLon) {
            globe_tooltip.style("opacity", 0);
            globe_activeTooltip = null;
            return;
          }
          
          const distance = d3.geoDistance([d.lon, d.lat], centerLon);
          if (distance > Math.PI / 2) {
            // On back of globe
            globe_tooltip.style("opacity", 0);
            globe_activeTooltip = null;
            return;
          }
          
          // If this is a new tooltip (different from the previous one), trigger ripple animation
          if (globe_activeTooltip !== key) {
            globe_createRipple(d.lat, d.lon);
          }
          
          const city = d.city && d.city.trim();
          const country = d.country && d.country.trim();
          const title = city ? `${city}, ${country || "Unknown"}` : (country || "Unknown");

          // Position tooltip relative to the dot's screen position
          const svgRect = globe_svg.node().getBoundingClientRect();
          const containerRect = globe_container.node().getBoundingClientRect();
          const x = svgRect.left - containerRect.left + proj[0];
          const y = svgRect.top - containerRect.top + proj[1];

          globe_tooltip
            .style("left", x + "px")
            .style("top", y + "px")
            .style("opacity", 1)
            .html(`
              <strong>${title}</strong><br/>
               ${globe_formatFullDateTime(d.lastVisit, d.lat, d.lon)}
            `);
          
          globe_activeTooltip = key;
        } else if (globe_activeTooltip) {
          // No scheduled tooltip for current rotation
          globe_tooltip.style("opacity", 0);
          globe_activeTooltip = null;
        }
      }

      function globe_updateVisibleCount() {
        let visibleVisitors = 0;
        
        globe_visitData.forEach(d => {
          const proj = globe_projection([d.lon, d.lat]);
          if (!proj) return;
          
          // Check if point is on the visible hemisphere
          const distance = d3.geoDistance([d.lon, d.lat], globe_projection.invert([globe_size / 2, globe_size / 2]));
          if (distance <= Math.PI / 2) {
            visibleVisitors += d.visitors;
          }
        });
        
        d3.select("#globe-frame #visible-visitors").text(visibleVisitors.toLocaleString());
      }

      function globe_formatLastVisit(iso) {
        if (!iso) return "unknown";
        const date = new Date(iso);
        if (isNaN(date.getTime())) return iso;

        const year = date.getFullYear();

        if (year >= 2025) {
          return date.toLocaleString(undefined, {
            year: "numeric",
            month: "short",
          });
        } else if (year === 2024) {
          return "2024";
        } else {
          return "2023";
        }
      }

      function globe_formatFullDateTime(iso, lat, lon) {
        if (!iso) return "unknown";
        
        // Parse the ISO string and treat it as Pacific Time
        // The input timestamps are in Pacific Time but don't have timezone info
        // So we need to parse them as if they're in Pacific Time
        
        // First, parse as if it's in Pacific Time by adding the timezone
        const pacificDate = new Date(iso + (iso.includes('Z') || iso.includes('+') || iso.includes('-') ? '' : '-08:00'));
        if (isNaN(pacificDate.getTime())) return iso;

        // Try to get the timezone for the location
        let targetTimezone = null;
        try {
          if (typeof tzlookup !== 'undefined' && lat != null && lon != null) {
            targetTimezone = tzlookup(lat, lon);
          }
        } catch (e) {
          console.warn("Timezone lookup failed for", lat, lon, e);
        }

        // If we couldn't determine the timezone, show in Pacific Time
        if (!targetTimezone) {
          targetTimezone = "America/Los_Angeles";
        }

        // Format the date in the target timezone
        try {
          const formatted = pacificDate.toLocaleString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
            timeZone: targetTimezone
          });
          
          // Add timezone abbreviation
          const tzAbbr = pacificDate.toLocaleString("en-US", {
            timeZoneName: "short",
            timeZone: targetTimezone
          }).split(" ").pop();
          
          return `${formatted} ${tzAbbr}`;
        } catch (e) {
          console.warn("Timezone formatting failed:", e);
          // Fallback to Pacific Time
          return pacificDate.toLocaleString("en-US", {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
            timeZone: "America/Los_Angeles"
          }) + " PST";
        }
      }
    </script>

    <!-- MAP SCRIPT -->
    <script>
      // ============ MAP VARIABLES ============
      const map_baseWidth = 1920;
      const map_baseHeight = 960;
      const map_minRadius = 4.0;
      const map_maxRadius = 20.0;
      const map_theme = {
        landFill: "#dcd7ba",
        landStroke: "#1f1f28",
        waterFill: "#2d4f67",
        bubbleFill: "#7aa89f",
        bubbleStroke: "#3d6b62",
        bubbleFillHover: "#b31d1d",
        bubbleStrokeHover: "#db5555",
        bubbleOpacity: 0.75,
      };


      const map_container = d3.select("#map-frame");
      const map_tooltip = d3.select("#map-frame .tooltip");
      
      // State: zoom level and pan offset
      let map_zoomState = {
        scale: 1,
        translateX: 0,
        translateY: 0,
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        dragStartTranslateX: 0,
        dragStartTranslateY: 0
      };

      // Determine initial scale based on viewport width
      const map_viewportWidth = window.innerWidth || document.documentElement.clientWidth;
      if (map_viewportWidth < 800) {
        map_zoomState.scale = 0.6;
      } else if (map_viewportWidth < 1200) {
        map_zoomState.scale = 0.8;
      }

      let map_svg, map_worldData, map_visitData;

      // Load both world map data and visitor data
      Promise.all([
        d3.json("https://unpkg.com/world-atlas@2/countries-110m.json"),
        d3.json("https://unpkg.com/world-atlas@2/countries-50m.json"),
        d3.json("output/visitors-data.json")
      ]).then(([world110m, world50m, visitorData]) => {
        map_worldData = { low: world110m, high: world50m };
        map_visitData = visitorData;
        
        // Calculate total visitors
        const mapTotalVisitors = map_visitData.reduce((sum, d) => sum + d.visitors, 0);
        d3.select("#map-frame #total-visitors").text(mapTotalVisitors.toLocaleString());
        
        map_render();
        map_setupZoomButtons();
        
        // Add legend after first render
        const legend = d3.select("#map-frame")
          .append("div")
          .attr("class", "legend");
        legend.append("div").attr("class", "legend-dot");
        legend.append("span").text("Visitor locations (circle size ≈ relative visitors)");
      }).catch(error => {
        console.error("Error loading map data:", error);
        d3.select("#map-frame").append("div")
          .style("padding", "20px")
          .style("color", "#ff6b6b")
          .text("Error loading visitor data. Please ensure visitors-data.json is available.");
      });

      function map_render() {
        // Clear existing SVG
        map_container.selectAll("svg").remove();

        // ViewBox stays constant, but we scale the projection
        const width = map_baseWidth;
        const height = map_baseHeight;

        // Create SVG
        map_svg = map_container
          .insert("svg", ":first-child")
          .style("cursor", map_zoomState.isDragging ? "grabbing" : "grab")
          .attr("viewBox", `0 0 ${width} ${height}`);

        // Background
        // map_svg.append("rect")
        //   .attr("x", 0)
        //   .attr("y", 0)
        //   .attr("width", width)
        //   .attr("height", height);

        // Always use high resolution map (50m) for better detail
        const world = map_worldData.high;
        const countries = topojson.feature(world, world.objects.countries);

        // Scale and translate the projection
        const baseProjection = d3.geoNaturalEarth1()
          .fitSize([width, height], { type: "Sphere" });
        
        const baseScale = baseProjection.scale();
        const baseTranslate = baseProjection.translate();
        
        const projection = d3.geoNaturalEarth1()
          .scale(baseScale * map_zoomState.scale)
          .translate([
            baseTranslate[0] - map_zoomState.translateX,
            baseTranslate[1] - map_zoomState.translateY
          ]);

        const path = d3.geoPath(projection);

        // Graticule
        const graticule = d3.geoGraticule();

        map_svg.append("path")
          .datum(graticule.outline())
          .attr("fill", map_theme.waterFill)
          .attr("stroke", "none")
          .attr("d", path);

        map_svg.append("g")
          .selectAll("path")
          .data(countries.features)
          .join("path")
          .attr("fill", map_theme.landFill)
          .attr("stroke", map_theme.landStroke)
          .attr("stroke-width", 0.5)
          .attr("stroke-opacity", 0.6)
          .attr("fill-opacity", 0.9)
          .attr("d", path);

        map_svg.append("path")
          .datum(graticule())
          .attr("fill", "none")
          .attr("stroke", map_theme.gridStroke)
          .attr("stroke-width", 0.35)
          .attr("opacity", 0.5)
          .attr("d", path);

        // Draw points with constant screen size
        map_drawPoints(projection, width, height);

        // Update visible visitor count
        map_updateVisibleCount(projection);

        // Set up drag behavior
        map_setupDrag();
      }

      function map_updateVisibleCount(projection) {
        // Calculate which points are visible in the current viewport
        let visibleVisitors = 0;
        
        map_visitData.forEach(d => {
          const projected = projection([d.lon, d.lat]);
          if (!projected) return;
          
          const [x, y] = projected;
          
          // Check if the point is within the viewBox bounds
          if (x >= 0 && x <= map_baseWidth && y >= 0 && y <= map_baseHeight) {
            visibleVisitors += d.visitors;
          }
        });
        
        d3.select("#map-frame #visible-visitors").text(visibleVisitors.toLocaleString());
      }

      function map_drawPoints(projection, width, height) {
        if (!map_visitData || map_visitData.length === 0) return;

        const radii = map_visitData.map(d => d.normalized || 0);
        const maxNormalized = d3.max(radii) || 1;

        const radiusScale = d3.scaleLinear()
          .domain([0, maxNormalized])
          .range([map_minRadius, map_maxRadius]);

        // Draw larger points first so smaller points render on top
        const orderedData = [...map_visitData].sort((a, b) => (b.normalized || 0) - (a.normalized || 0));

        const circles = map_svg.append("g")
          .selectAll("circle")
          .data(orderedData)
          .join("circle")
          .attr("cx", d => projection([d.lon, d.lat])[0])
          .attr("cy", d => projection([d.lon, d.lat])[1])
          .attr("r", d => radiusScale(d.normalized || 0))
          .attr("fill", map_theme.bubbleFill)
          .attr("fill-opacity", map_theme.bubbleOpacity)
          .attr("stroke", map_theme.bubbleStroke)
          .attr("stroke-width", 1);

        circles
          .style("cursor", "default")
          .on("mouseover", function (event, d) {
            d3.select(this)
              .attr("fill", map_theme.bubbleFillHover)
              .attr("stroke", map_theme.bubbleStrokeHover)
              .attr("stroke-width", 1.4);

            const city = d.city && d.city.trim();
            const country = d.country && d.country.trim();
            const title = city ? `${city}, ${country || "Unknown"}` : (country || "Unknown");

            // Get screen coordinates relative to the map-frame container
            const svgRect = map_svg.node().getBoundingClientRect();
            const containerRect = map_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;

            map_tooltip
              .style("left", x + "px")
              .style("top", y + "px")
              .style("opacity", 1)
              .html(`
                <strong>${title}</strong><br/>
                Visitors: ${d.visitors.toLocaleString()}<br/>
                Most recent: ${map_formatLastVisit(d.lastVisit)}
              `);
          })
          .on("mousemove", function (event) {
            // Get screen coordinates relative to the map-frame container
            const containerRect = map_container.node().getBoundingClientRect();
            const x = event.clientX - containerRect.left;
            const y = event.clientY - containerRect.top;
            
            map_tooltip
              .style("left", x + "px")
              .style("top", y + "px");
          })
          .on("mouseout", function () {
            d3.select(this)
              .attr("fill", map_theme.bubbleFill)
              .attr("stroke", map_theme.bubbleStroke)
              .attr("stroke-width", 1.0);

            map_tooltip.style("opacity", 0);
          });
      }

      function map_setupDrag() {
        map_svg.on("mousedown", (event) => {
          map_zoomState.isDragging = true;
          map_zoomState.dragStartX = event.clientX;
          map_zoomState.dragStartY = event.clientY;
          map_zoomState.dragStartTranslateX = map_zoomState.translateX;
          map_zoomState.dragStartTranslateY = map_zoomState.translateY;
          map_svg.style("cursor", "grabbing");
          event.preventDefault();
        })
        .on("dblclick", (event) => {
          // Double-click to zoom in centered on mouse position
          const svgRect = map_svg.node().getBoundingClientRect();
          
          // Get mouse position relative to SVG in screen coordinates
          const mouseX = event.clientX - svgRect.left;
          const mouseY = event.clientY - svgRect.top;
          
          // Convert to viewBox coordinates (where the mouse is in the viewport)
          const viewBoxX = (mouseX / svgRect.width) * map_baseWidth;
          const viewBoxY = (mouseY / svgRect.height) * map_baseHeight;
          
          // Calculate what point in the world this corresponds to
          // The projection translates by: baseTranslate - map_zoomState.translate
          // So a point at viewBoxX in the viewport corresponds to a world point that,
          // when projected, gives us viewBoxX
          // Since projection.translate = [map_baseWidth/2 - translateX, map_baseHeight/2 - translateY]
          // A point at viewBoxX corresponds to world coordinates that project to viewBoxX
          
          // Store the old scale
          const oldScale = map_zoomState.scale;
          
          // Calculate the center offset before zoom (where in the viewport is the click relative to center)
          const offsetX = viewBoxX - map_baseWidth / 2;
          const offsetY = viewBoxY - map_baseHeight / 2;
          
          // Zoom in
          map_zoomState.scale = Math.min(8, map_zoomState.scale * 1.4);
          const zoomRatio = map_zoomState.scale / oldScale;
          
          // Adjust translation to keep the clicked point under the cursor
          // The offset from center should scale with the zoom
          map_zoomState.translateX = map_zoomState.translateX * zoomRatio + offsetX * (zoomRatio - 1);
          map_zoomState.translateY = map_zoomState.translateY * zoomRatio + offsetY * (zoomRatio - 1);
          
          // Constrain panning
          const scaledMapWidth = map_baseWidth * map_zoomState.scale;
          const scaledMapHeight = map_baseHeight * map_zoomState.scale;
          const maxTranslateX = Math.max(0, (scaledMapWidth - map_baseWidth) / 2);
          const maxTranslateY = Math.max(0, (scaledMapHeight - map_baseHeight) / 2);
          map_zoomState.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, map_zoomState.translateX));
          map_zoomState.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, map_zoomState.translateY));
          
          map_render();
          event.preventDefault();
        });

        d3.select(window)
          .on("mousemove.map", (event) => {
            if (!map_zoomState.isDragging) return;
            
            const dx = event.clientX - map_zoomState.dragStartX;
            const dy = event.clientY - map_zoomState.dragStartY;
            
            // Convert screen pixels to viewBox coordinates
            const svgRect = map_svg.node().getBoundingClientRect();
            const viewBoxWidth = map_baseWidth;
            const viewBoxHeight = map_baseHeight;
            const scaleX = viewBoxWidth / svgRect.width;
            const scaleY = viewBoxHeight / svgRect.height;
            
            map_zoomState.translateX = map_zoomState.dragStartTranslateX - dx * scaleX;
            map_zoomState.translateY = map_zoomState.dragStartTranslateY - dy * scaleY;
            
            // Constrain panning based on the scaled map size
            // When zoomed in, the map is larger than the viewBox, so we can pan more
            // The map should never show empty space beyond its edges
            const scaledMapWidth = viewBoxWidth * map_zoomState.scale;
            const scaledMapHeight = viewBoxHeight * map_zoomState.scale;
            
            // Max translate is how far we can pan before hitting the edge
            // At scale=1, maxTranslate=0 (can't pan at all)
            // At scale=2, maxTranslate=viewBoxWidth/2 (can pan half the width in each direction)
            const maxTranslateX = Math.max(0, (scaledMapWidth - viewBoxWidth) / 2);
            const maxTranslateY = Math.max(0, (scaledMapHeight - viewBoxHeight) / 2);
            
            map_zoomState.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, map_zoomState.translateX));
            map_zoomState.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, map_zoomState.translateY));
            
            map_render();
          })
          .on("mouseup.map", () => {
            if (map_zoomState.isDragging) {
              map_zoomState.isDragging = false;
              if (map_svg) map_svg.style("cursor", "grab");
            }
          });
      }

      function map_setupZoomButtons() {
        d3.select("#zoom-in").on("click", () => {
          const oldScale = map_zoomState.scale;
          map_zoomState.scale = Math.min(8, map_zoomState.scale * 1.4);
          const zoomRatio = map_zoomState.scale / oldScale;
          
          // Scale the translation to keep the center point stable
          map_zoomState.translateX = map_zoomState.translateX * zoomRatio;
          map_zoomState.translateY = map_zoomState.translateY * zoomRatio;
          
          // Constrain panning after zoom
          const scaledMapWidth = map_baseWidth * map_zoomState.scale;
          const scaledMapHeight = map_baseHeight * map_zoomState.scale;
          const maxTranslateX = Math.max(0, (scaledMapWidth - map_baseWidth) / 2);
          const maxTranslateY = Math.max(0, (scaledMapHeight - map_baseHeight) / 2);
          map_zoomState.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, map_zoomState.translateX));
          map_zoomState.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, map_zoomState.translateY));
          
          map_render();
        });

        d3.select("#zoom-out").on("click", () => {
          const oldScale = map_zoomState.scale;
          map_zoomState.scale = Math.max(0.5, map_zoomState.scale / 1.4);
          const zoomRatio = map_zoomState.scale / oldScale;
          
          // Scale the translation to keep the center point stable
          map_zoomState.translateX = map_zoomState.translateX * zoomRatio;
          map_zoomState.translateY = map_zoomState.translateY * zoomRatio;
          
          // Constrain panning after zoom out - important to prevent being out of bounds
          const scaledMapWidth = map_baseWidth * map_zoomState.scale;
          const scaledMapHeight = map_baseHeight * map_zoomState.scale;
          const maxTranslateX = Math.max(0, (scaledMapWidth - map_baseWidth) / 2);
          const maxTranslateY = Math.max(0, (scaledMapHeight - map_baseHeight) / 2);
          map_zoomState.translateX = Math.max(-maxTranslateX, Math.min(maxTranslateX, map_zoomState.translateX));
          map_zoomState.translateY = Math.max(-maxTranslateY, Math.min(maxTranslateY, map_zoomState.translateY));
          
          map_render();
        });
      }

      function map_formatLastVisit(iso) {
        if (!iso) return "unknown";
        const date = new Date(iso);
        if (isNaN(date.getTime())) return iso;

        const year = date.getFullYear();

        // Bucketization rules:
        // - Dates in 2025: show "Mon 2025" (e.g., "Jan 2025")
        // - Dates in 2024 (before 2025-01-01): show "2024"
        // - Dates in 2023 or earlier (before 2024-01-01): show "2023"
        if (year >= 2025) {
          return date.toLocaleString(undefined, {
            year: "numeric",
            month: "short",
          });
        } else if (year === 2024) {
          return "2024";
        } else {
          return "2023";
        }
      }
    </script>
  
  </body>
</html>
